#!/bin/bash

# EKS Upgrade Assessment Validation Script
# Generated by EKS Upgrade Assessment Toolkit

set -e

# Configuration
AWS_REGION="{{ aws_region }}"
AWS_PROFILE="{{ aws_profile }}"
CLUSTERS=({% for cluster_name in cluster_names %}"{{ cluster_name }}"{% if not loop.last %} {% endif %}{% endfor %})

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    # Check AWS CLI
    if ! command -v aws &> /dev/null; then
        log_error "AWS CLI is not installed"
        exit 1
    fi
    
    # Check kubectl
    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl is not installed"
        exit 1
    fi
    
    # Check kubent (optional)
    if ! command -v kubent &> /dev/null; then
        log_warning "kubent is not installed - deprecated API scanning will be skipped"
    fi
    
    # Check pluto (optional)
    if ! command -v pluto &> /dev/null; then
        log_warning "pluto is not installed - deprecated API scanning will be skipped"
    fi
    
    log_success "Prerequisites check completed"
}

# Validate AWS credentials and region
validate_aws_access() {
    log_info "Validating AWS access..."
    
    if ! aws sts get-caller-identity --profile "$AWS_PROFILE" --region "$AWS_REGION" &> /dev/null; then
        log_error "Failed to validate AWS credentials"
        exit 1
    fi
    
    log_success "AWS access validated"
}

# Check cluster accessibility
check_cluster_access() {
    local cluster_name=$1
    log_info "Checking access to cluster: $cluster_name"
    
    # Update kubeconfig
    if ! aws eks update-kubeconfig --region "$AWS_REGION" --name "$cluster_name" --profile "$AWS_PROFILE" &> /dev/null; then
        log_error "Failed to update kubeconfig for cluster: $cluster_name"
        return 1
    fi
    
    # Test cluster connectivity
    if ! kubectl get nodes --request-timeout=10s &> /dev/null; then
        log_error "Failed to connect to cluster: $cluster_name"
        return 1
    fi
    
    log_success "Cluster access validated: $cluster_name"
    return 0
}

# Check cluster version
check_cluster_version() {
    local cluster_name=$1
    log_info "Checking cluster version: $cluster_name"
    
    local version=$(aws eks describe-cluster --name "$cluster_name" --region "$AWS_REGION" --profile "$AWS_PROFILE" --query 'cluster.version' --output text)
    
    if [ -z "$version" ]; then
        log_error "Failed to get cluster version for: $cluster_name"
        return 1
    fi
    
    log_info "Cluster $cluster_name version: $version"
    return 0
}

# Run deprecated API scan
run_deprecated_api_scan() {
    local cluster_name=$1
    log_info "Running deprecated API scan for: $cluster_name"
    
    # Update kubeconfig for this cluster
    aws eks update-kubeconfig --region "$AWS_REGION" --name "$cluster_name" --profile "$AWS_PROFILE" &> /dev/null
    
    # Run kubent if available
    if command -v kubent &> /dev/null; then
        log_info "Running kubent scan..."
        if kubent --output json > "/tmp/${cluster_name}_kubent.json" 2>/dev/null; then
            local kubent_issues=$(jq length "/tmp/${cluster_name}_kubent.json" 2>/dev/null || echo "0")
            if [ "$kubent_issues" -gt 0 ]; then
                log_warning "kubent found $kubent_issues deprecated API issues in $cluster_name"
            else
                log_success "kubent found no deprecated API issues in $cluster_name"
            fi
        else
            log_warning "kubent scan failed for $cluster_name"
        fi
    fi
    
    # Run pluto if available
    if command -v pluto &> /dev/null; then
        log_info "Running pluto scan..."
        if pluto detect-all-in-cluster --output json > "/tmp/${cluster_name}_pluto.json" 2>/dev/null; then
            local pluto_issues=$(jq '.items | length' "/tmp/${cluster_name}_pluto.json" 2>/dev/null || echo "0")
            if [ "$pluto_issues" -gt 0 ]; then
                log_warning "pluto found $pluto_issues deprecated API issues in $cluster_name"
            else
                log_success "pluto found no deprecated API issues in $cluster_name"
            fi
        else
            log_warning "pluto scan failed for $cluster_name"
        fi
    fi
}

# Check node groups
check_node_groups() {
    local cluster_name=$1
    log_info "Checking node groups for: $cluster_name"
    
    local nodegroups=$(aws eks list-nodegroups --cluster-name "$cluster_name" --region "$AWS_REGION" --profile "$AWS_PROFILE" --query 'nodegroups' --output text)
    
    if [ -z "$nodegroups" ] || [ "$nodegroups" = "None" ]; then
        log_info "No managed node groups found for: $cluster_name"
        return 0
    fi
    
    for nodegroup in $nodegroups; do
        log_info "Checking node group: $nodegroup"
        
        local ng_info=$(aws eks describe-nodegroup --cluster-name "$cluster_name" --nodegroup-name "$nodegroup" --region "$AWS_REGION" --profile "$AWS_PROFILE" --query 'nodegroup.{version:version,status:status,health:health.issues}' --output json)
        
        local ng_version=$(echo "$ng_info" | jq -r '.version')
        local ng_status=$(echo "$ng_info" | jq -r '.status')
        local ng_health=$(echo "$ng_info" | jq -r '.health')
        
        log_info "Node group $nodegroup - Version: $ng_version, Status: $ng_status"
        
        if [ "$ng_status" != "ACTIVE" ]; then
            log_warning "Node group $nodegroup is not in ACTIVE status: $ng_status"
        fi
        
        if [ "$ng_health" != "null" ] && [ "$ng_health" != "[]" ]; then
            log_warning "Node group $nodegroup has health issues: $ng_health"
        fi
    done
}

# Check addons
check_addons() {
    local cluster_name=$1
    log_info "Checking addons for: $cluster_name"
    
    local addons=$(aws eks list-addons --cluster-name "$cluster_name" --region "$AWS_REGION" --profile "$AWS_PROFILE" --query 'addons' --output text)
    
    if [ -z "$addons" ] || [ "$addons" = "None" ]; then
        log_info "No addons found for: $cluster_name"
        return 0
    fi
    
    for addon in $addons; do
        log_info "Checking addon: $addon"
        
        local addon_info=$(aws eks describe-addon --cluster-name "$cluster_name" --addon-name "$addon" --region "$AWS_REGION" --profile "$AWS_PROFILE" --query 'addon.{version:addonVersion,status:status,health:health.issues}' --output json)
        
        local addon_version=$(echo "$addon_info" | jq -r '.version')
        local addon_status=$(echo "$addon_info" | jq -r '.status')
        local addon_health=$(echo "$addon_info" | jq -r '.health')
        
        log_info "Addon $addon - Version: $addon_version, Status: $addon_status"
        
        if [ "$addon_status" != "ACTIVE" ]; then
            log_warning "Addon $addon is not in ACTIVE status: $addon_status"
        fi
        
        if [ "$addon_health" != "null" ] && [ "$addon_health" != "[]" ]; then
            log_warning "Addon $addon has health issues: $addon_health"
        fi
    done
}

# Main execution
main() {
    log_info "Starting EKS Upgrade Assessment Validation"
    log_info "AWS Region: $AWS_REGION"
    log_info "AWS Profile: $AWS_PROFILE"
    log_info "Clusters: ${CLUSTERS[*]}"
    
    check_prerequisites
    validate_aws_access
    
    for cluster in "${CLUSTERS[@]}"; do
        log_info "Processing cluster: $cluster"
        
        if check_cluster_access "$cluster"; then
            check_cluster_version "$cluster"
            run_deprecated_api_scan "$cluster"
            check_node_groups "$cluster"
            check_addons "$cluster"
        else
            log_error "Skipping further checks for inaccessible cluster: $cluster"
        fi
        
        echo "----------------------------------------"
    done
    
    log_success "Assessment validation completed"
    
    # Cleanup temporary files
    rm -f /tmp/*_kubent.json /tmp/*_pluto.json
}

# Run main function
main "$@"
